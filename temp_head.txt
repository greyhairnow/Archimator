#!/usr/bin/env python3
"""
GUI client for the architectural diagram measurement tool.

This script uses the Tkinter GUI library to provide a native windowed
experience for loading a PDF of an architectural drawing, measuring rooms by
drawing polygons, setting a reference scale, exporting measurement data and
performing simple panel layout optimisation.  It includes conveniences such
as zooming, panning, rotating the loaded image, a zoom preview window and
tools for editing polygons (straightening, vertex dragging).  It is designed
for use on platforms where Tkinter is available (e.g. a standard Python
installation on Windows, macOS or Linux with the Tk libraries installed).

Features:
  * Load a PDF and display the first page on a canvas.
  * Zoom in/out and pan the diagram via buttons or rightâ€‘click dragging.
  * Rotate the diagram in 90Â° increments.
  * Draw room outlines as polygons directly on the diagram.
  * Set a reference scale by drawing a line of known length; scale lines
    remain visible after confirmation.
  * Compute area and perimeter for each polygon in real units based on the
    scale factor.
  * Attach metadata (room ID and name) to polygons.
  * Export all measurements and metadata to a CSV file.
  * Generate a simple 3D extrusion of all rooms.
  * Optimise panel layout within a selected room using a simple tiling
    algorithm.
  * Straighten polygons by converting nearâ€‘right angles to perfectly straight
    segments, and undo the operation if necessary.
  * Drag individual polygon vertices (nonâ€‘right angles) to fineâ€‘tune shapes.
  * Zoom preview window to help accurately place scale and polygon points.

Note: This script requires Tkinter to be installed.  It cannot run in
headless environments (such as this sandbox) where a GUI cannot be created.
Run it locally on a system with a graphical desktop. 
"""

import importlib
import importlib.util
import json
import math
import os
import sys
from dataclasses import dataclass, field
from typing import List, Tuple, Optional

# Ensure required third-party packages are available before proceeding.
REQUIRED_PACKAGES = {
    "pymupdf": "pymupdf",
    "PIL": "pillow",
    "matplotlib": "matplotlib",
}

missing_packages = [
    package_name
    for module_name, package_name in REQUIRED_PACKAGES.items()
    if importlib.util.find_spec(module_name) is None
]

if missing_packages:
    unique = sorted(set(missing_packages))
    package_list = " ".join(unique)
    message = (
        "Missing required packages: "
        + ", ".join(unique)
        + "\nInstall them with: pip install "
        + package_list
    )
    print(message, file=sys.stderr)
    raise SystemExit(1)

import pymupdf as fitz  # Alias to retain existing usage
from PIL import Image

try:
    import tkinter as tk
    from tkinter import filedialog, simpledialog, messagebox
    from PIL import ImageTk
except ImportError:
    # When Tkinter is unavailable (e.g. headless environment), set tk to None.
    tk = None  # type: ignore

import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401


def pdf_page_to_image(pdf_path: str, page_number: int = 0) -> Image.Image:
    """Load the specified page of a PDF and convert it to a PIL Image."""
    with open(pdf_path, 'rb') as f:
        doc = fitz.open(stream=f.read(), filetype='pdf')
    if page_number < 0 or page_number >= len(doc):
        raise ValueError(f"Invalid page number {page_number} for PDF with {len(doc)} pages")
    page = doc.load_page(page_number)
    # Render at ~144 DPI for good detail (zoom factor 2).
    zoom = 2
    mat = fitz.Matrix(zoom, zoom)
    pix = page.get_pixmap(matrix=mat)
    mode = 'RGB' if pix.alpha == 0 else 'RGBA'
    img = Image.frombytes(mode, [pix.width, pix.height], pix.samples)
    return img


def generate_3d_image(polygons: List[List[Tuple[float, float]]], height: float = 1.0) -> Image.Image:
    """Generate a static 3D extrusion plot and return it as a PIL Image."""
    fig = plt.figure(figsize=(6, 6))
    ax = fig.add_subplot(111, projection='3d')
    for idx, pts in enumerate(polygons):
        if len(pts) < 3:
            continue
        xs = [p[0] for p in pts] + [pts[0][0]]
        ys = [p[1] for p in pts] + [pts[0][1]]
        zs_bottom = [0] * len(xs)
        zs_top = [height] * len(xs)
        color = f'C{idx % 10}'
        ax.plot(xs, ys, zs_bottom, color=color, alpha=0.6)
        ax.plot(xs, ys, zs_top, color=color, alpha=0.6)
        for i in range(len(pts)):
            x0, y0 = pts[i]
            ax.plot([x0, x0], [y0, y0], [0, height], color=color, alpha=0.6)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Height')
    # Normalise axes to [0,1] for consistency; caller is expected to normalise
    # polygon coordinates relative to the page before calling this function.
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)
    ax.set_zlim(0, height)
    ax.view_init(elev=20, azim=30)
    ax.grid(False)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_zticks([])
    buf = os.path.join('/tmp', 'extrusion.png')
    fig.savefig(buf, format='png', bbox_inches='tight')
    plt.close(fig)
    img = Image.open(buf)
    return img


from .model import (
    PolygonData,
    shoelace_area,
    polygon_perimeter,
    point_in_polygon,
)


class MeasureAppGUI:
    """Main class encapsulating the Tkinter application."""

    def __init__(self, root: tk.Tk) -> None:
        self.root = root
        self.root.title("Architectural Diagram Measurement Tool")
        # Set a reasonable default size; user may resize later.
        self.root.geometry("1200x800")
        # Main frame contains canvas and control areas.
        main_frame = tk.Frame(root)
        main_frame.pack(fill=tk.BOTH, expand=True)
        # Frame to hold canvas and its pan/zoom controls below.
        canvas_frame = tk.Frame(main_frame)
        canvas_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        # Canvas used to display the PDF image and drawings.
        # Starting size gives a reasonable default; will be adjusted once a PDF
        # is loaded.
        self.canvas = tk.Canvas(canvas_frame, bg='gray', width=800, height=600)
        self.canvas.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        # Controls for pan, zoom and rotation beneath the canvas.
        ctrl_canvas_frame = tk.Frame(canvas_frame)
        ctrl_canvas_frame.pack(side=tk.BOTTOM, fill=tk.X)
        self.pan_zoom_buttons: List[tk.Button] = []
        self.add_pan_zoom_buttons(ctrl_canvas_frame)
        # Rotation buttons.
        self.rotate_left_btn = tk.Button(ctrl_canvas_frame, text="Rotate Left", command=self.rotate_left)
        self.rotate_left_btn.pack(side=tk.LEFT, padx=2)
        self.rotate_right_btn = tk.Button(ctrl_canvas_frame, text="Rotate Right", command=self.rotate_right)
        self.rotate_right_btn.pack(side=tk.LEFT, padx=2)
        # Control panel on the right for file loading and measurement options.
        side_frame = tk.Frame(main_frame)
        side_frame.pack(side=tk.RIGHT, fill=tk.Y)
        tk.Button(side_frame, text="Load PDF", command=self.load_pdf).pack(fill=tk.X)
        tk.Button(side_frame, text="Load Config", command=self.load_config).pack(fill=tk.X)
        tk.Button(side_frame, text="Save Config", command=self.save_config).pack(fill=tk.X)
        tk.Button(side_frame, text="Set Unit/Scale", command=self.set_scale_mode).pack(fill=tk.X)
        tk.Button(side_frame, text="Draw Polygon", command=self.set_draw_mode).pack(fill=tk.X)
        tk.Button(side_frame, text="Export CSV", command=self.export_csv).pack(fill=tk.X)
        tk.Button(side_frame, text="3D View", command=self.show_3d_view).pack(fill=tk.X)
        tk.Button(side_frame, text="Optimize Panels", command=self.optimize_panels).pack(fill=tk.X)
        tk.Button(side_frame, text="Straighten Polygon", command=self.straighten_polygon).pack(fill=tk.X)
        tk.Button(side_frame, text="Undo Straighten", command=self.undo_straighten).pack(fill=tk.X)
        # Labels to display the current scale and selection info.
        self.scale_unit = "units"
        self.scale_label = tk.Label(side_frame, text=f"Scale: 1.0 {self.scale_unit}/pixel")
        self.scale_label.pack(fill=tk.X, pady=(10, 0))
        self.info_label = tk.Label(side_frame, text="No polygon selected.")
        self.info_label.pack(fill=tk.X)
        # Bind mouse events for drawing, panning and dragging.
        # Left mouse button handles drawing polygons and selecting regions.
        self.canvas.bind("<Button-1>", self.on_canvas_click)
        # Right mouse button for panning via scan functionality.
        self.canvas.bind("<ButtonPress-3>", self.on_pan_start)
        self.canvas.bind("<B3-Motion>", self.on_pan_move)
        # Motion event for zoom preview (enabled only in drawing/scale modes).
        self.canvas.bind("<Motion>", self.on_canvas_motion)
        # Dragging vertices (left button press, move and release) outside of draw/scale mode.
        # Use add='+' to avoid overwriting the existing <Button-1> binding
        self.canvas.bind("<ButtonPress-1>", self.on_drag_start, add="+")
        self.canvas.bind("<B1-Motion>", self.on_drag_move)
        self.canvas.bind("<ButtonRelease-1>", self.on_drag_end)
        # Data structures and state variables.
        self.image: Optional[Image.Image] = None  # Original PDF page (resized to fit)
        self.photo: Optional[ImageTk.PhotoImage] = None  # PhotoImage for Tkinter display
        self.display_image: Optional[Image.Image] = None  # PIL image currently shown on canvas (after rotation/zoom)
        self.polygons: List[PolygonData] = []  # Completed polygons
        self.current_polygon: List[Tuple[float, float]] = []  # Points of polygon being drawn
        self.draw_mode: bool = False  # True when drawing a new polygon
        self.scale_mode: bool = False  # True when setting the scale line
        self.scale_points: List[Tuple[float, float]] = []  # Two points selected for scale
        self.scale_artifact: Optional[dict] = None  # Persistent scale line info
        self.scale_marker_id: Optional[int] = None  # Canvas ID for first scale point marker
        self.scale_line_id: Optional[int] = None  # Canvas ID for scale line
        self.scale_factor: float = 1.0  # Units per pixel
        self.selected_polygon: Optional[int] = None  # Index of currently selected polygon
        # Configuration (panel size and extrusion height)
        self.config = {
            'panel_width': 1.0,
            'panel_height': 1.0,
            'extrusion_height': 1.0
        }
        # Scale preview state
        self.scale_preview_line_id: Optional[int] = None  # Canvas ID for rubber-band preview
        # Zoom/pan/rotation state
        self.zoom_level: float = 1.0
        self.image_rotation: int = 0  # Rotation in degrees (0, 90, 180, 270)
        # Straightening backup for undo
        self._straighten_backup: Optional[List[Tuple[float, float]]] = None
        # Zoom preview window and configuration
        self.zoom_preview_win: Optional[tk.Toplevel] = None
        self.zoom_preview_label: Optional[tk.Label] = None
        self.zoom_preview_size: int = 80  # Size of zoom preview window (pixels)
        self.zoom_preview_zoom: float = 1.6  # Zoom factor for preview
        # Dragging state
        self.dragging: bool = False
        self.drag_point_index: Optional[int] = None
        self.drag_start_x: float = 0.0
        self.drag_start_y: float = 0.0

    # ----- Pan/Zoom/Rotate Button Setup -----
    def add_pan_zoom_buttons(self, frame: tk.Frame) -> None:
        """Add pan and zoom buttons to the provided frame."""
        # Clear any existing buttons (useful when reinitialising)
        for btn in self.pan_zoom_buttons:
            btn.destroy()
        self.pan_zoom_buttons.clear()
        # Zoom controls
        self.pan_zoom_buttons.append(tk.Button(frame, text="Zoom In", command=self.zoom_in))
        self.pan_zoom_buttons.append(tk.Button(frame, text="Zoom Out", command=self.zoom_out))
        # Pan controls (move by 50 units at current zoom level)
        self.pan_zoom_buttons.append(tk.Button(frame, text="Pan Left", command=lambda: self.pan_canvas(-50, 0)))
        self.pan_zoom_buttons.append(tk.Button(frame, text="Pan Right", command=lambda: self.pan_canvas(50, 0)))
        self.pan_zoom_buttons.append(tk.Button(frame, text="Pan Up", command=lambda: self.pan_canvas(0, -50)))
        self.pan_zoom_buttons.append(tk.Button(frame, text="Pan Down", command=lambda: self.pan_canvas(0, 50)))
        for btn in self.pan_zoom_buttons:
            btn.pack(side=tk.LEFT, padx=2)

    # ----- Rotation Controls -----
    def rotate_left(self) -> None:
        """Rotate the image 90Â° counterâ€‘clockwise."""
        if self.image is None:
            return
        # Update rotation state and reapply rotation
        self.image_rotation = (self.image_rotation - 90) % 360
        self.apply_rotation()

    def rotate_right(self) -> None:
        """Rotate the image 90Â° clockwise."""
        if self.image is None:
            return
        self.image_rotation = (self.image_rotation + 90) % 360
        self.apply_rotation()

    def apply_rotation(self) -> None:
        """Apply the current rotation to the image and transform polygons and scale markers accordingly."""
        if self.image is None:
            return
        # Rotate the original image (before scaling) and update PhotoImage
        img = self.image.rotate(-self.image_rotation, expand=True)
        # Also apply current zoom level
        if self.zoom_level != 1.0:
            new_size = (int(img.width * self.zoom_level), int(img.height * self.zoom_level))
            try:
                resample = Image.Resampling.LANCZOS
            except AttributeError:
                resample = Image.LANCZOS
            img = img.resize(new_size, resample)
        self.photo = ImageTk.PhotoImage(img)
        self.display_image = img
        self.display_image = img
        # Update canvas scroll region
        self.canvas.config(scrollregion=(0, 0, img.width, img.height))
        # Transform existing polygons and scale points only when rotation
        # changes (note: this operation is destructive on stored points).
        if self.image_rotation != 0 and self.image is not None:
            # Use the original (resized) image dimensions before rotation to calculate center
            w, h = self.image.size
            # After rotation, new dimensions of rotated image (before zoom)
            temp_rotated = self.image.rotate(-self.image_rotation, expand=True)
            new_w, new_h = temp_rotated.size
            # Offset between original and rotated due to expansion
            offset_x = (new_w - w) / 2
            offset_y = (new_h - h) / 2
            def rotate_point(px: float, py: float, width: float, height: float, angle: int) -> Tuple[float, float]:
                """Rotate a point (px,py) around the centre of an image of size width x height by angle degrees."""
                angle_rad = math.radians(angle)
                cx, cy = width / 2, height / 2
                dx, dy = px - cx, py - cy
                rx = dx * math.cos(angle_rad) - dy * math.sin(angle_rad)
                ry = dx * math.sin(angle_rad) + dy * math.cos(angle_rad)
                return rx + cx, ry + cy
            # Transform polygons
            for poly in self.polygons:
                transformed = [rotate_point(x, y, w, h, self.image_rotation) for (x, y) in poly.points]
                # Adjust for expansion offset
                transformed = [(x + offset_x, y + offset_y) for (x, y) in transformed]
                poly.points = transformed
                poly.compute_metrics()
            # Transform current polygon
            self.current_polygon = [rotate_point(x, y, w, h, self.image_rotation) for (x, y) in self.current_polygon]
            self.current_polygon = [(x + offset_x, y + offset_y) for (x, y) in self.current_polygon]
            # Transform scale points
            self.scale_points = [rotate_point(x, y, w, h, self.image_rotation) for (x, y) in self.scale_points]
            self.scale_points = [(x + offset_x, y + offset_y) for (x, y) in self.scale_points]
            # Update scale artifact if present
            if self.scale_artifact and 'points' in self.scale_artifact:
                pts = self.scale_artifact['points']
                pts = [rotate_point(x, y, w, h, self.image_rotation) for (x, y) in pts]
                pts = [(x + offset_x, y + offset_y) for (x, y) in pts]
                self.scale_artifact['points'] = pts
        # Redraw the canvas
        self.redraw()

    # ----- Zoom and Pan -----
    def zoom_in(self) -> None:
        """Increase zoom level and redraw the image."""
        self.set_zoom(self.zoom_level * 1.2)

    def zoom_out(self) -> None:
        """Decrease zoom level and redraw the image."""
        self.set_zoom(self.zoom_level / 1.2)

    def set_zoom(self, zoom: float) -> None:
        """Set a new zoom level within allowable bounds and redraw the image."""
        if self.image is None:
            return
        zoom = max(0.2, min(zoom, 5.0))
        self.zoom_level = zoom
        # Start from the original resized image and apply zoom and rotation.
        img = self.image
        # Apply rotation first to preserve orientation before scaling
        if self.image_rotation != 0:
            img = img.rotate(-self.image_rotation, expand=True)
        # Apply zoom by resizing
        new_size = (int(img.width * self.zoom_level), int(img.height * self.zoom_level))
        try:
            resample = Image.Resampling.LANCZOS
        except AttributeError:
            resample = Image.LANCZOS
        img = img.resize(new_size, resample)
        self.photo = ImageTk.PhotoImage(img)
        self.display_image = img
        # Update scroll region for panning
        self.canvas.config(scrollregion=(0, 0, img.width, img.height))
        # Redraw contents at new zoom level
        self.redraw()

    def pan_canvas(self, dx: int, dy: int) -> None:
        """Pan the canvas by the specified amount (in canvas units)."""
        self.canvas.xview_scroll(int(dx), 'units')
        self.canvas.yview_scroll(int(dy), 'units')

    # ----- Panning via Rightâ€‘click Dragging -----
    def on_pan_start(self, event) -> None:
        """Record the starting point for a panning operation (rightâ€‘click)."""
        self.canvas.scan_mark(event.x, event.y)

    def on_pan_move(self, event) -> None:
        """Handle panning while dragging with the right mouse button."""
        self.canvas.scan_dragto(event.x, event.y, gain=1)

    # ----- File and Configuration Management -----
    def load_pdf(self) -> None:
        """Prompt the user to select a PDF file and load its first page."""
        path = filedialog.askopenfilename(title="Select PDF", filetypes=[("PDF files", "*.pdf")])
        if not path:
            return
        try:
            img = pdf_page_to_image(path)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load PDF: {e}")
